<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<head>
  <style>

  .link {
    stroke: gray;
    stroke-width: .8px;
  }

  .node {
    fill: white;
    stroke: #000;
    stroke-width: .9px;
  }

  .node:hover {
    fill: black;
  }
  .text{
	fill: black;
	stroke-width: 0px;
  font-size: .9em;
  }
  </style>
</head>
<body>
 <table>
    <tr>
      <td>Layout:</td>
      <td><label><input type="radio" name="layout" value="force" checked> Force</label>
      </td>
    </tr>
    <tr>
      <td></td>
      <td style="text-align: right;">&#9658;</td>
      <td>Rankings:</td>
      <td><label><input type="radio" name="ranking" value="norank" checked> None</label>
      </td>
      <td><label><input type="radio" name="ranking" value="rank" > Rankings</label>
        &nbsp;&nbsp;&nbsp;
      </td>
      <td>Key:<select id="selectKeys" onchange="keyChanged(this);">
      <option value="gdp" selected="selected"> GDP</option>
      <option value="population" > Population</option>
      <option value="life_expectancy" > Life_expectancy</option>
      </select>
      </td>
    </tr>
    <tr>
      <td></td>
      <td style="text-align: right;">&#9658;</td>
      <td>Scatterplot:</td>
      <td><label><input type="radio" name="ranking" value="growth"> Population/GDP</label>
      </td>
      <td><label><input type="radio" name="ranking" value="location" > Longitude/Latitude</label>
      </td>
    </tr>
    <tr>
      <td></td>
      <td><label><input type="radio" name="layout" value="circular"> Circular</label> 
      </td>
    </tr>
    <tr>
      <td></td>
      <td style="text-align: right;">&#9658;</td>
      <td>Sortkey:</td>
      <td><label><input type="radio" name="circle" value="cir_gdp" checked> GDP</label>
      </td>
      <td><label><input type="radio" name="circle" value="cir_pop" > Population</label>
    </tr>
    <tr>
      <td></td>
      <td style="text-align: right;">&#9658;</td>
      <td>Grouped:</td>
      <td><label><input type="radio" name="circle2" value="cir_none" checked> None </label>
      </td>
      <td><label><input type="radio" name="circle2" value="cir_grouped"> By Continent </label>
      </td>
    </tr>
    <tr>
      <td></td>
      <td><label><input type="radio" name="layout" value="grouped"> Grouped</label> 
      </td>
    </tr>
    <tr>
      <td></td>
      <td style="text-align: right;">&#9658;</td>
      <td>Shape:</td>
      <td><label><input type="radio" name="group" value="gr_none" checked> None </label>
      </td>
      <td><label><input type="radio" name="group" value="gr_horizontal" checked> Horizontal </label>
      </td>
      <td><label><input type="radio" name="group" value="gr_pie" > Pie </label>
    </tr>
 </table>
    <script src="d3.min.js"></script>
    <script>

//layout
  d3.select("input[value=\"force\"]").on("click", force_layout);
  d3.select("input[value=\"circular\"]").on("click", circular_layout);
  d3.select("input[value=\"grouped\"]").on("click", grouped_layout);  

//force
  d3.select("input[value=\"norank\"]").on("click", force_layout);
  d3.select("input[value=\"rank\"]").on("click", force_layout);
  d3.select("input[value=\"growth\"]").on("click", force_layout);
  d3.select("input[value=\"location\"]").on("click", force_layout);

//circular
  d3.select("input[value=\"cir_gdp\"]").on("click", circular_layout);
  d3.select("input[value=\"cir_pop\"]").on("click", circular_layout);
  d3.select("input[value=\"cir_none\"]").on("click", circular_layout);
  d3.select("input[value=\"cir_grouped\"]").on("click", circular_layout);

//grouped
  d3.select("input[value=\"gr_horizontal\"]").on("click", grouped_layout);
  d3.select("input[value=\"gr_pie\"]").on("click", grouped_layout);
  d3.select("input[value=\"gr_none\"]").on("click", grouped_layout);


  var sorting = ""; //status of sorting 'asc' or 'desc'
  var lastSelectedCol = ""; //selected column for sorting last time 
  var dataset = []; //mapped data
  var selectedYear = ""; //hold selected year in range
  var selDataset = []; //filtered data by year
  var selConti = []; //selection of continents among filter checkbox
  var selKey = "gdp"; //rank key default 
  var group_shape = "none"
  var continents = ["Americas","Africa","Asia","Europe","Oceania"];

    //initialize barchart(Gloval)
	var margin = {top: 5, bottom: 5, left: 10, right: 10};
	var width = 1500 - margin.left - margin.right;
	var height = 1500 - margin.top - margin.bottom;

	var svg = d3.select("body").append("svg")
	            .attr("width", width)
	            .attr("height", height);

	var fill = d3.scale.category10();

	var graph = {nodes: [], links: []};
  var centroid_xy =[];

  var nameScale = d3.scale.ordinal().rangeRoundBands([0, height], .8, 0);

	var xScale = d3.scale.linear();
  var yScale = d3.scale.linear();
  var xScale_loc = d3.scale.linear();
  var yScale_loc = d3.scale.linear();
  var xyScale = d3.scale.linear();

	var node_scale = d3.scale.linear();

	//SETTING GRAPH.NODES
	graph.nodes = d3.range(120).map(function() {  
	  return { 
	    cat: 1
	  }; 
	})

	// Generate the force layout
	var force = d3.layout.force()
	    .size([width, height])
	    .charge(-50) //between nodes, so they will repel each other more
	    //.linkDistance(10) //the length of the edges between connected nodes
      .gravity(0.07) //dedault 0.1
      .friction(0.9) //default 0.9
	    .on("tick", tick)
	    .on("start", function(d) {}) //animation
	    .on("end", function(d) {}) //animation

 	var node = svg.selectAll(".node")
      .data(graph.nodes)
      .enter()
      .append("g").attr("class", "node");

	node.append("circle")
	    .attr("r", 5);

	node.append("text")
  		.attr("x", 10)
  		.attr("y", 4)
  		.attr("class","text")
  		.text("test");



    //DATA LOAD
    d3.json("data/countries_1995_2012.json", function(error, data){

  		//mapping
  		data.map(function(d,i){
  		    for (i = 0; i < d.years.length; i++) {
  		        var dat = {
  		          name: d.name,
  		          continent: d.continent,
  		          gdp: d.years[i].gdp,
  		          life_expectancy: d.years[i].life_expectancy,
  		          population: d.years[i].population,
  		          year: d.years[i].year,
                latitude: d.latitude,
                longitude: d.longitude
  		        };

  		        dataset.push(dat);
  		    }
  		});

  		rangechanged("2012");

      force.nodes(graph.nodes)
            //.links(graph.links)
      .start();

      sortingdata(selDataset,"gdp");
  		graph_update_norank();

	  }); //End json loading

	function tick(e) {
	   //graph_update(100);
     // if (e.alpha <= 0.06) {

    switch(group_shape){
        case "gr_none":
          //nothing
          break;
        case "gr_horizontal":
          var k = 10 * e.alpha;
          //console.log(e.alpha)
          graph.nodes.forEach(function(o, i) {
              switch(o.cont){
                  case continents[0]: //Americas
                      o.x -= k*2;
                      break;
                   case continents[1]: //Africa
                      o.x -= k;
                      break;
                  case continents[2]: //Asia
                      //o.x +- 0
                      break;
                  case continents[3]: //Europe
                      o.x += k;
                      break;
                  case continents[4]: //Oceania
                      o.x += k*2;
                      break;             
              }
          });
          break;
        case "gr_pie":
            var k = 6 * e.alpha;

            graph.nodes.forEach(function(o, i) {
                //grouped pie

                //Americas 
                switch(o.cont){
                    case continents[0]:
                        o.x += xyScale(centroid_xy[0].x)*k
                        o.y += xyScale(centroid_xy[0].y)*k
                        break;
                    //Africa
                    case continents[1]:
                        o.x += xyScale(centroid_xy[1].x)*k
                        o.y += xyScale(centroid_xy[1].y)*k
                        break;
                    //Asia
                    case continents[2]:
                        o.x += xyScale(centroid_xy[2].x)*k
                        o.y += xyScale(centroid_xy[2].y)*k
                        break;
                    //Europe
                    case continents[3]:
                        o.x += xyScale(centroid_xy[3].x)*k
                        o.y += xyScale(centroid_xy[3].y)*k
                        break;
                    //Oceania
                    case continents[4]:
                        o.x += xyScale(centroid_xy[4].x)*k
                        o.y += xyScale(centroid_xy[4].y)*k
                        break;
                  }
            });
            break;
    }

    node
      .attr("transform", function(d) { return "translate("+d.x+","+d.y+")"; })
    //  }
  }

  function sortingdata(vdataset,keyval){
      selDataset = selDataset.sort(function(a, b) {
              return d3.descending(a[keyval], b[keyval]);
      });
  }

	function graph_update(duration) {

	  node.transition().duration(duration)
	      .attr("transform", function(d) { 
	        return "translate("+d.x+","+d.y+")"; 
	      })
	      .attr("id",function(d){
	      	return d.cat;
	      })
	      .select("text")
	      .text(function(d){ return d.cat});	  
	}

  function graph_update_norank() { //(1)

    force.stop();

    //scale-----
    nameScale.domain(selDataset.map(function(d) {
         return d.name;
    }));

    graph.nodes.forEach(function(d, i) {
      d.x = width/3;
      d.y = nameScale(selDataset[i].name);
      d.cat = selDataset[i].name;
      d.cont = selDataset[i].continent;
      d.pop = selDataset[i].population;
      d.gdp = selDataset[i].gdp;
    })

    graph_update(500);
  }

	function graph_update_rank() { //(2)

	  force.stop();

    var min = 0;
    if(selKey == "life_expectancy"){
        min = selDataset[selDataset.length-1][selKey];
    }

    node_scale
        .domain([min, selDataset[0][selKey]])
        .range([5, height-10]);

	  graph.nodes.forEach(function(d, i) {
      d.x = width/3;
	    d.y = height - node_scale(selDataset[i][selKey]);
      d.cat = selDataset[i].name;
	  })

	  graph_update(500);
	}

	function graph_update_growth() { //(3)

	  force.stop();

      xScale
        .domain([0,d3.max(selDataset.map(function(d) { return d.gdp; }))])
        .range([5, height-100]);
      yScale
        .domain([0,d3.max(selDataset.map(function(d) { return d.population; }))])
        .range([5, width-50]);

	  graph.nodes.forEach(function(d, i) {
	    // d.x = height - xScale(selDataset[i].gdp);
     //  d.y = yScale(selDataset[i].population);
      d.x = xScale(selDataset[i].gdp);
      d.y = height - yScale(selDataset[i].population);
      d.cat = selDataset[i].name;
	  })

	  graph_update(500);
	}

	function graph_update_location() { //(4)

    force.stop();

      xScale_loc
        .domain([-180,180])
        .range([0, width-20]);
      yScale_loc
        .domain([-180,180])
        .range([0, height]);

    graph.nodes.forEach(function(d, i) {
      d.x = xScale_loc(selDataset[i].longitude) -200;
      d.y = height - yScale_loc(selDataset[i].latitude);
      d.cat = selDataset[i].name;
    })
	  graph_update(500);
	}

  function keyChanged(selVal){
      
      selKey = selVal.value //save to gloval

      var selGraph = "";
      
      sortingdata(selDataset,selKey); //sort

      force_layout();
  }

  function force_layout(){
      var selGraph = "";
      
      sortingdata(selDataset,selKey); //sort

      d3.selectAll("input").each(function(d) {
          if(d3.select(this).attr("name") == "ranking" && d3.select(this).node().checked) {
              selGraph = d3.select(this).attr("value");
          }
      });

      switch(selGraph){
        case("norank"):
            graph_update_norank();
            break;
        case("rank"):
            graph_update_rank();
            break;
        case("growth"):
            graph_update_growth();
            break;
        case("location"):
            graph_update_location();
            break;
      };
  }

  function circular_layout(){

      force.stop();

      //get sortkey
      var sortkey_circle
      var grouped_circle
      d3.selectAll("input").each(function(d) {
          if(d3.select(this).attr("name") == "circle" && d3.select(this).node().checked) {
              sortkey_circle = d3.select(this).attr("value");
          }else if(d3.select(this).attr("name") == "circle2" && d3.select(this).node().checked) {
              grouped_circle = d3.select(this).attr("value");
          }

      });

      var arc = d3.svg.arc()
              
      var pie = d3.layout.pie()
      switch(sortkey_circle){
          case "cir_gdp":
              pie.sort(function(a, b) { return a.gdp - b.gdp;}) // Sorting by categories
              break;
          case "cir_pop":
              pie.sort(function(a, b) { return a.pop - b.pop;}) // Sorting by categories
              break;
      }
      pie.value(function(d, i) { 
          return 1;  // We want an equal pie share/slice for each point
      });

      switch(grouped_circle){
          case "cir_none":
              var r = Math.min(height, width)/2;
              arc.outerRadius(r);

              pie(graph.nodes).map(function(d, i) {
                // Needed to caclulate the centroid
                d.innerRadius = 0;
                d.outerRadius = r;

                // Building the data object we are going to return
                d.data.x = arc.centroid(d)[0]+width/2;
                d.data.y = arc.centroid(d)[1]+height/2;

                return d.data;
              })
              break;
          case "cir_grouped":
              var r = 200;
              arc.outerRadius(r);

              get_centroid();

              continents.forEach(function(o,j){
                    pie(graph.nodes.filter(function(d){return d.cont == o })).map(function(d, i) {
                     // Needed to caclulate the centroid
                    d.innerRadius = 0;
                    d.outerRadius = r;        

                    // Building the data object we are going to return
                    d.data.x = arc.centroid(d)[0] + (centroid_xy[j].x *3) + width/2;
                    d.data.y = arc.centroid(d)[1] + (centroid_xy[j].y *3) + height/2;

                    return d.data;
                  })
              });
              //graph.nodes = tmpnodes;
              break;
      }

      graph_update(500);
  }

  function grouped_layout(){

    //force.stop();
    //get sortkey 
    d3.selectAll("input").each(function(d) {
        if(d3.select(this).attr("name") == "group" && d3.select(this).node().checked) {
            group_shape = d3.select(this).attr("value");
        }
    });

    if(group_shape == "gr_pie"){
        get_centroid();
    }


    force.nodes(graph.nodes)
      //.links(graph.links)
      .start();

  }

    function create_piedata(){
        var piedata = [];
        //continents = ["Americas","Africa","Asia","Europe","Oceania"];
        continents.forEach(function(e){
            var count = selDataset.filter(function(d){return d.continent == e});
            piedata.push(count.length);
        })
     
        return piedata;
    }

    function get_centroid(){
        //var piedata = [22, 27, 35, 33, 3];
        var piedata = create_piedata();

        var outerRadius = 250;
        var innerRadius = 0;
        var arc = d3.svg.arc()
                .innerRadius(innerRadius)
                .outerRadius(outerRadius);
        
        var pie = d3.layout.pie();
        //Set up groups
        var arcs = svg.selectAll("g.arc")
                .data(pie(piedata))
                .enter()
                .append("g")
                .attr("class", "arc")
                .attr("transform", "translate(" + (outerRadius+250) + "," + outerRadius + ")");
        
        //Draw arc paths
        //invisible pie chart
        arcs.append("path")
            .attr("fill", "transparent")
            .attr("stroke","black")
            .attr("d", arc)
            .attr("visibility","hidden"); 
        
        //Labels
        //invisible pie chart
        arcs.append("text")
            .attr("transform", function(d,i) {
              centroid_xy.push({x:arc.centroid(d)[0],y:arc.centroid(d)[1]})
              //console.log(centroid_xy)
              return "translate(" + arc.centroid(d) + ")";
            })
            .attr("text-anchor", "middle")
            .text(function(d) {
              return d.value;
            })
            .attr("visibility","hidden");

        xyScale
              .domain([-125,125])
              .range([-2,2]);
    }



    //Range
    function rangechanged(newVal){

        var indexed_data = []
        var tmpdata = []

        //preserve in Global
        selectedYear = newVal;

        dataset.map(function(d,i){
            if (d.year == newVal){
                tmpdata.push(d);  
            }
            indexed_data[newVal] = tmpdata
        });

        //preserve in Global
        selDataset = indexed_data[newVal];
        
        //check aggrigation, filter etc
        //distributeFunc();
    };


    </script> 
  </body>
</html>